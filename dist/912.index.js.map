{"version":3,"sources":["webpack://stalk-demo-raft-consensus/webpack/runtime/chunk loaded","webpack://stalk-demo-raft-consensus/webpack/runtime/startup chunk dependencies","webpack://stalk-demo-raft-consensus/./src/raft/opentelemetry-webworker-fix.ts","webpack://stalk-demo-raft-consensus/./src/raft/worker-messaging-interfaces.ts","webpack://stalk-demo-raft-consensus/./src/globals/server-config.ts","webpack://stalk-demo-raft-consensus/./src/raft/raft-interfaces.ts","webpack://stalk-demo-raft-consensus/./src/raft/worker-stalk-span-exporter.ts","webpack://stalk-demo-raft-consensus/./src/raft/server-worker.ts","webpack://stalk-demo-raft-consensus/webpack/bootstrap","webpack://stalk-demo-raft-consensus/webpack/runtime/ensure chunk","webpack://stalk-demo-raft-consensus/webpack/runtime/get javascript chunk filename","webpack://stalk-demo-raft-consensus/webpack/runtime/global","webpack://stalk-demo-raft-consensus/webpack/runtime/hasOwnProperty shorthand","webpack://stalk-demo-raft-consensus/webpack/runtime/node module decorator","webpack://stalk-demo-raft-consensus/webpack/runtime/publicPath","webpack://stalk-demo-raft-consensus/webpack/runtime/importScripts chunk loading","webpack://stalk-demo-raft-consensus/webpack/startup"],"names":["deferred","next","window","self","RaftServerWorkerMessageType","RaftServerState","RaftServerEvents","WorkerStalkSpanExporter","id","this","spans","resultCallback","_sendSpans","Promise","resolve","span","startTime","hrTimeToMilliseconds","references","parentSpanId","push","type","spanId","traceId","spanContext","links","forEach","link","context","logs","events","map","event","timestamp","time","fields","attributes","name","process","serviceName","tags","operationName","finishTime","duration","done","message","EXPORT_SPAN","payload","_exportInfo","postMessage","JSON","stringify","code","ExportResultCode","tracer","sleep","ms","setTimeout","minSpanDuration","votedFor","electionTimeoutId","state","STOPPED","term","log","peers","commitIndex","rpcTimeoutIds","rpcSpans","sendMessageToPeer","timeout","to","delay","Math","random","sendMessage","MESSAGE_TO_PEER","PROXY_EVENT","SENT_MESSAGE","setAttributes","error","addEvent","messageType","end","termChanged","noop","CANDIDATE","resending","sendRequestVoteMessage","LEADER","sendAppendEntriesMessage","handleMessageTimeout","reloadElectionTimeout","parentSpan","clearTimeout","handleElectionTimeout","SET_ELECTION_TIMEOUT","FOLLOWER","ctx","startSpan","dumpStateAsSpanAttributes","Object","values","peer","voteGranted","matchIndex","nextIndex","sendStateUpdate","STARTED_NEW_ELECTION","stepDown","term_","STEPPED_DOWN","peerId","generateMessageId","from","lastLogTerm","logTerm","length","lastLogIndex","prevIndex","lastIndex","min","prevTerm","entries","slice","e","value","join","l","i","STATE_UPDATE","toString","substring","index","addEventListener","parse","data","INIT","id_","peerIds","heartbeatTimeoutId","provider","BasicTracerProvider","addSpanProcessor","SimpleSpanProcessor","register","setupTracing","READY","MESSAGE_FROM_PEER","success","incomingTerm","myTerm","entry","pop","max","RECIEVED_APPEND_ENTRIES","handleAppendEntriesMessage","matchIndexes","sort","a","b","n","floor","keys","advanceCommitIndex","handleAppendEntriesResponse","granted","for","VOTED","handleRequestVoteMessage","RECIEVED_VOTE","quorum","ceil","grantedVotes","CLEARED_ELECTION_TIMEOUT","BECAME_LEADER","handleRequestVoteResponse","START","STARTED","start","STOP","stop","REQUEST","LOG_REQUESTED","request","FORCE_TRIGGER_ELECTION","forceTriggerElection","LOADED","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","undefined","exports","module","loaded","__webpack_modules__","call","m","x","__webpack_exports__","O","result","chunkIds","fn","priority","notFulfilled","Infinity","fulfilled","j","every","key","splice","f","chunkId","all","reduce","promises","u","g","globalThis","Function","o","obj","prop","prototype","hasOwnProperty","nmd","paths","children","scriptUrl","importScripts","location","document","currentScript","src","scripts","getElementsByTagName","Error","replace","p","installedChunks","912","chunkLoadingGlobal","parentChunkLoadingFunction","bind","moreModules","runtime","then"],"mappings":"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","file":"912.index.js","sourcesContent":["var deferred = [];\n__webpack_require__.O = (result, chunkIds, fn, priority) => {\n\tif(chunkIds) {\n\t\tpriority = priority || 0;\n\t\tfor(var i = deferred.length; i > 0 && deferred[i - 1][2] > priority; i--) deferred[i] = deferred[i - 1];\n\t\tdeferred[i] = [chunkIds, fn, priority];\n\t\treturn;\n\t}\n\tvar notFulfilled = Infinity;\n\tfor (var i = 0; i < deferred.length; i++) {\n\t\tvar [chunkIds, fn, priority] = deferred[i];\n\t\tvar fulfilled = true;\n\t\tfor (var j = 0; j < chunkIds.length; j++) {\n\t\t\tif ((priority & 1 === 0 || notFulfilled >= priority) && Object.keys(__webpack_require__.O).every((key) => (__webpack_require__.O[key](chunkIds[j])))) {\n\t\t\t\tchunkIds.splice(j--, 1);\n\t\t\t} else {\n\t\t\t\tfulfilled = false;\n\t\t\t\tif(priority < notFulfilled) notFulfilled = priority;\n\t\t\t}\n\t\t}\n\t\tif(fulfilled) {\n\t\t\tdeferred.splice(i--, 1)\n\t\t\tresult = fn();\n\t\t}\n\t}\n\treturn result;\n};","var next = __webpack_require__.x;\n__webpack_require__.x = () => {\n\treturn __webpack_require__.e(745).then(next);\n};","// Opentelemetry.js does not work in webworkers. It depends on either\n// `window` object or `global`/`process` object. This is a workaround\n// inspired by: https://stackoverflow.com/a/38752760\n//\n// Why a seperate file? Because webpack hoists all the import statements\n// in the output bundle file. So even if we write the following line at the\n// top of file, it doesn't work.\nif (typeof window != 'object') (self as any).window = self;\n","export interface RaftServerWorkerMessage {\n  type: RaftServerWorkerMessageType;\n  payload?: any;\n}\n\nexport enum RaftServerWorkerMessageType {\n  LOADED = 'loaded', // worker -> ui\n  INIT = 'init', // ui -> worker\n  READY = 'ready', // worker -> ui\n  STATE_UPDATE = 'stateUpdate', // worker -> ui\n  MESSAGE_TO_PEER = 'messageToPeer', // worker -> ui\n  MESSAGE_FROM_PEER = 'messageFromPeer', // ui -> worker\n  PROXY_EVENT = 'proxyEvent', // worker -> ui\n  STOP = 'stop', // ui -> worker\n  START = 'start', // ui -> worker\n  REQUEST = 'request', // ui -> worker\n  FORCE_TRIGGER_ELECTION = 'forceTriggerElectrion', // ui -> worker\n  EXPORT_SPAN = 'exportSpan', // worker -> ui\n}\n","// Shared-singleton object\nconst serverConfig = getDefaults();\n\nexport function getDefaults() {\n  return {\n    MIN_MESSAGE_DELAY: 1000,\n    MAX_MESSAGE_DELAY: 1500,\n    RPC_TIMEOUT: 5000,\n    MIN_ELECTION_TIMEOUT: 10000,\n    MAX_ELECTION_TIMEOUT: 20000,\n    HEARTBEAT_INTERVAL: 3000,\n    BATCH_SIZE: 1,\n  };\n}\n\nexport function getRealistic() {\n  return {\n    MIN_MESSAGE_DELAY: 50,\n    MAX_MESSAGE_DELAY: 100,\n    RPC_TIMEOUT: 250,\n    MIN_ELECTION_TIMEOUT: 750,\n    MAX_ELECTION_TIMEOUT: 1200,\n    HEARTBEAT_INTERVAL: 200,\n    BATCH_SIZE: 1,\n  };\n}\n\nexport default serverConfig;\n","export enum RaftServerState {\n  FOLLOWER = 'follower',\n  CANDIDATE = 'candidate',\n  LEADER = 'leader',\n  STOPPED = 'stopped',\n}\n\nexport enum RaftServerEvents {\n  SENT_MESSAGE = 'sent message',\n  CLEARED_ELECTION_TIMEOUT = 'cleared election timeout',\n  SET_ELECTION_TIMEOUT = 'set election timeout',\n  STARTED_NEW_ELECTION = 'started new election',\n  STEPPED_DOWN = 'stepped down',\n  VOTED = 'voted',\n  RECIEVED_VOTE = 'recieved vote',\n  BECAME_LEADER = 'became leader',\n  RECIEVED_APPEND_ENTRIES = 'recieved append entries',\n  STARTED = 'started',\n  STOPPED = 'stopped',\n  LOG_REQUESTED = 'log requested',\n}\n\nexport interface RaftLogItem {\n  term: number;\n  value: string;\n}\n\nexport type RaftMessage =\n  | RequestVoteMessage\n  | RequestVoteResponseMessage\n  | AppendEntriesMessage\n  | AppendEntriesResponseMessage;\n\nexport interface RequestVoteMessage {\n  id: string;\n  from: string;\n  to: string;\n  term: number;\n  type: 'RequestVote';\n  lastLogTerm: number;\n  lastLogIndex: number;\n}\n\nexport interface RequestVoteResponseMessage {\n  id: string;\n  from: string;\n  to: string;\n  term: number;\n  type: 'RequestVoteResponse';\n  granted: boolean;\n}\n\nexport interface AppendEntriesMessage {\n  id: string;\n  from: string;\n  to: string;\n  term: number;\n  type: 'AppendEntries';\n  prevIndex: number;\n  prevTerm: number;\n  entries: RaftLogItem[];\n  commitIndex: number;\n}\n\nexport interface AppendEntriesResponseMessage {\n  id: string;\n  from: string;\n  to: string;\n  term: number;\n  type: 'AppendEntriesResponse';\n  success: boolean;\n  matchIndex: number;\n}\n","import { SpanExporter, ReadableSpan } from '@opentelemetry/tracing';\nimport {\n  ExportResult,\n  ExportResultCode,\n  hrTimeToMilliseconds,\n} from '@opentelemetry/core';\nimport {\n  RaftServerWorkerMessage,\n  RaftServerWorkerMessageType,\n} from './worker-messaging-interfaces';\n\n/**\n * This class is derived from:\n * https://github.com/open-telemetry/opentelemetry-js/blob/f045eef8b02e6dda452aab3cdbeaf78b225c2fd4/packages/opentelemetry-tracing/src/export/ConsoleSpanExporter.ts\n *\n * Which converts otel spans directly to Stalk's span interface:\n * https://github.com/dgurkaynak/stalk/blob/ba4aba14b296a95974b3472bbde79d4a9290bb23/src/model/interfaces.ts\n */\nexport class WorkerStalkSpanExporter implements SpanExporter {\n  id: string;\n\n  constructor(id: string) {\n    this.id = id;\n  }\n\n  export(\n    spans: ReadableSpan[],\n    resultCallback: (result: ExportResult) => void\n  ): void {\n    return this._sendSpans(spans, resultCallback);\n  }\n\n  shutdown(): Promise<void> {\n    this._sendSpans([]);\n    return Promise.resolve();\n  }\n\n  private _exportInfo(span: ReadableSpan) {\n    const startTime = hrTimeToMilliseconds(span.startTime);\n    const references: {\n      type: 'childOf' | 'followsFrom';\n      spanId: string;\n      traceId: string;\n    }[] = [];\n\n    if (span.parentSpanId) {\n      references.push({\n        type: 'childOf',\n        spanId: span.parentSpanId,\n        traceId: span.spanContext.traceId,\n      });\n    }\n\n    span.links.forEach((link) => {\n      references.push({\n        type: 'followsFrom', // I think jaeger assumes all the span links as follows from\n        spanId: link.context.spanId,\n        traceId: link.context.traceId,\n      });\n    });\n\n    const logs = span.events.map((event) => {\n      return {\n        timestamp: hrTimeToMilliseconds(event.time),\n        fields: {\n          ...event.attributes,\n          name: event.name\n        },\n      };\n    });\n    const process = {\n      serviceName: `raft-server-${this.id}`,\n      tags: {},\n    };\n\n    return {\n      id: span.spanContext.spanId,\n      traceId: span.spanContext.traceId,\n      operationName: span.name,\n      startTime,\n      finishTime: startTime + hrTimeToMilliseconds(span.duration),\n      references,\n      tags: span.attributes,\n      logs,\n      process,\n    };\n  }\n\n  private _sendSpans(\n    spans: ReadableSpan[],\n    done?: (result: ExportResult) => void\n  ): void {\n    for (const span of spans) {\n      const message: RaftServerWorkerMessage = {\n        type: RaftServerWorkerMessageType.EXPORT_SPAN,\n        payload: this._exportInfo(span),\n      };\n      (self.postMessage as any)(JSON.stringify(message));\n    }\n    if (done) {\n      return done({ code: ExportResultCode.SUCCESS });\n    }\n  }\n}\n","import './opentelemetry-webworker-fix';\nimport * as opentelemetry from '@opentelemetry/api';\nimport {\n  BasicTracerProvider,\n  ConsoleSpanExporter,\n  SimpleSpanProcessor,\n  BatchSpanProcessor,\n} from '@opentelemetry/tracing';\nimport { CollectorTraceExporter } from '@opentelemetry/exporter-collector';\nimport {\n  RaftServerWorkerMessage,\n  RaftServerWorkerMessageType,\n} from './worker-messaging-interfaces';\nimport cfg from '../globals/server-config';\nimport {\n  RaftServerState,\n  RaftServerEvents,\n  RaftLogItem,\n  RaftMessage,\n  RequestVoteMessage,\n  RequestVoteResponseMessage,\n  AppendEntriesMessage,\n  AppendEntriesResponseMessage,\n} from './raft-interfaces';\nimport { WorkerStalkSpanExporter } from './worker-stalk-span-exporter';\n\ninterface PeerRaftServer {\n  id: string;\n  voteGranted: boolean;\n  matchIndex: number;\n  nextIndex: number;\n  heartbeatTimeoutId: number;\n}\n\n// General variables\nlet tracer: opentelemetry.Tracer;\nconst sleep = (ms: number) => new Promise((resolve) => setTimeout(resolve, ms));\nconst minSpanDuration = cfg.MIN_MESSAGE_DELAY;\n\n// Public state (exposed to UI)\nlet state = RaftServerState.STOPPED;\nlet term = 1;\nlet votedFor: string;\nlet log: RaftLogItem[] = [];\nlet peers: { [key: string]: PeerRaftServer } = {};\n\n// Internal state\nlet id: string;\nlet commitIndex = 0;\nlet rpcTimeoutIds: { [key: string]: number } = {};\nlet rpcSpans: { [key: string]: opentelemetry.Span } = {};\nlet electionTimeoutId: number;\n\nfunction sendMessageToPeer(message: RaftMessage, timeout = 0) {\n  const peer = peers[message.to];\n  if (!peer) return;\n\n  const delay =\n    cfg.MIN_MESSAGE_DELAY +\n    Math.random() * (cfg.MAX_MESSAGE_DELAY - cfg.MIN_MESSAGE_DELAY);\n\n  setTimeout(() => {\n    sendMessage({\n      type: RaftServerWorkerMessageType.MESSAGE_TO_PEER,\n      payload: message,\n    });\n  }, delay);\n\n  debug(`Sending ${message.type} message to ${message.to}`, message);\n  sendMessage({\n    type: RaftServerWorkerMessageType.PROXY_EVENT,\n    payload: {\n      type: RaftServerEvents.SENT_MESSAGE,\n      message,\n      delay,\n    },\n  });\n\n  if (timeout > 0) {\n    rpcTimeoutIds[message.id] = setTimeout(() => {\n      delete rpcTimeoutIds[message.id];\n      handleMessageTimeout(message);\n    }, timeout) as any;\n  }\n}\n\nfunction clearElectionTimeout() {\n  clearTimeout(electionTimeoutId);\n  electionTimeoutId = null;\n\n  sendMessage({\n    type: RaftServerWorkerMessageType.PROXY_EVENT,\n    payload: {\n      type: RaftServerEvents.CLEARED_ELECTION_TIMEOUT,\n    },\n  });\n}\n\nfunction reloadElectionTimeout(parentSpan: opentelemetry.Span) {\n  clearTimeout(electionTimeoutId);\n  const delay =\n    cfg.MIN_ELECTION_TIMEOUT +\n    Math.random() * (cfg.MAX_ELECTION_TIMEOUT - cfg.MIN_ELECTION_TIMEOUT);\n\n  electionTimeoutId = setTimeout(\n    () => handleElectionTimeout(parentSpan),\n    delay\n  ) as any;\n\n  parentSpan?.addEvent('election-timeout-reset', { timeout: delay });\n  sendMessage({\n    type: RaftServerWorkerMessageType.PROXY_EVENT,\n    payload: {\n      type: RaftServerEvents.SET_ELECTION_TIMEOUT,\n      delay,\n    },\n  });\n}\n\n// Can be in 4 states\nasync function handleElectionTimeout(parentSpan: opentelemetry.Span) {\n  if (state == RaftServerState.STOPPED) {\n    return;\n  }\n\n  if (state == RaftServerState.LEADER) {\n    return;\n  }\n\n  if (state == RaftServerState.CANDIDATE || state == RaftServerState.FOLLOWER) {\n    const ctx = opentelemetry.setSpan(\n      opentelemetry.context.active(),\n      parentSpan\n    );\n    const span = tracer.startSpan('startNewElection', {}, ctx);\n    span.setAttributes({ ...dumpStateAsSpanAttributes() });\n    debug(`Election timeout, starting a new one...`);\n\n    // Starting new election\n    reloadElectionTimeout(span);\n    term += 1;\n    votedFor = id;\n    state = RaftServerState.CANDIDATE;\n\n    Object.values(peers).forEach((peer) => {\n      peer.voteGranted = false;\n      peer.matchIndex = 0;\n      peer.nextIndex = 1;\n    });\n\n    sendStateUpdate();\n    sendMessage({\n      type: RaftServerWorkerMessageType.PROXY_EVENT,\n      payload: {\n        type: RaftServerEvents.STARTED_NEW_ELECTION,\n      },\n    });\n\n    // We're updating `term` and `peers.matchIndex`\n    // we're sure that we're not leader, but just in case\n    // advanceCommitIndex();\n\n    // Send request messages\n    Object.values(peers).forEach((peer) => {\n      sendRequestVoteMessage(span, peer.id);\n    });\n\n    await sleep(minSpanDuration); // make the span visually pleasing\n    span.end();\n\n    return;\n  }\n}\n\nfunction stepDown(parentSpan: opentelemetry.Span, term_: number) {\n  state = RaftServerState.FOLLOWER;\n  term = term_;\n  votedFor = null;\n  reloadElectionTimeout(parentSpan);\n\n  sendStateUpdate();\n  sendMessage({\n    type: RaftServerWorkerMessageType.PROXY_EVENT,\n    payload: {\n      type: RaftServerEvents.STEPPED_DOWN,\n    },\n  });\n\n  // We're updating `term`\n  // we're sure that we're not leader, but just in case\n  // advanceCommitIndex();\n}\n\nfunction sendRequestVoteMessage(\n  parentSpan: opentelemetry.Span,\n  peerId: string\n) {\n  const span = tracer.startSpan('requestVote', {\n    links: [{ context: parentSpan?.context() }],\n  });\n\n  const message: RequestVoteMessage = {\n    id: generateMessageId(),\n    from: id,\n    to: peerId,\n    term: term,\n    type: 'RequestVote',\n    lastLogTerm: logTerm(log, log.length),\n    lastLogIndex: log.length,\n  };\n\n  span.setAttributes({\n    to: peerId,\n    term: term,\n    lastLogTerm: message.lastLogTerm,\n    lastLogIndex: message.lastLogIndex,\n  });\n  const ctx = opentelemetry.setSpan(opentelemetry.context.active(), span);\n  opentelemetry.propagation.inject(ctx, message);\n  rpcSpans[message.id] = span;\n\n  sendMessageToPeer(message, cfg.RPC_TIMEOUT);\n}\n\n// Can be in 3 states\nasync function handleRequestVoteMessage(message: RequestVoteMessage) {\n  const ctx = opentelemetry.propagation.extract(\n    opentelemetry.context.active(),\n    message\n  );\n  const span = tracer.startSpan('handleRequestVote', {}, ctx);\n  span.setAttributes({\n    ...dumpStateAsSpanAttributes(),\n    'request.term': message.term,\n    'request.lastLogTerm': message.lastLogTerm,\n    'request.lastLogIndex': message.lastLogIndex,\n  });\n\n  debug(`Recieved ${message.type} message from ${message.from}`, message);\n\n  if (term < message.term) {\n    const logMessage = `Incoming term (${message.term}) is higher than my term (${term}), stepping down`;\n    debug(logMessage);\n    span.addEvent('stepping-down', {\n      incomingTerm: message.term,\n      myTerm: term,\n    });\n    stepDown(span, message.term);\n  }\n\n  let granted = false;\n\n  if (\n    term == message.term &&\n    (!votedFor || votedFor == message.from) &&\n    (message.lastLogTerm > logTerm(log) ||\n      (message.lastLogTerm == logTerm(log) &&\n        message.lastLogIndex >= log.length))\n  ) {\n    const logMessage = `Voted for ${message.from}`;\n    debug(logMessage);\n    span.addEvent('voted', { for: message.from });\n\n    granted = true;\n    votedFor = message.from;\n    reloadElectionTimeout(span);\n\n    sendStateUpdate();\n    sendMessage({\n      type: RaftServerWorkerMessageType.PROXY_EVENT,\n      payload: {\n        type: RaftServerEvents.VOTED,\n      },\n    });\n  }\n\n  const response: RequestVoteResponseMessage = {\n    ...message,\n    from: id,\n    to: message.from,\n    term: term,\n    type: 'RequestVoteResponse',\n    granted,\n  };\n  sendMessageToPeer(response);\n\n  span.setAttributes({ granted });\n\n  await sleep(minSpanDuration); // make the span visually pleasing\n  span.end();\n}\n\n// Can be in 3 states\nfunction handleRequestVoteResponse(message: RequestVoteResponseMessage) {\n  const span = rpcSpans[message.id];\n  delete rpcSpans[message.id];\n  span?.addEvent('response-recieved', {\n    // ...dumpState(),\n    'response.term': message.term,\n    'response.granted': message.granted,\n  });\n  if (!message.granted) {\n    span?.setAttributes({ error: 'not granted' });\n  }\n\n  debug(`Recieved ${message.type} message from ${message.from}`, message);\n\n  if (term < message.term) {\n    const logMessage = `Incoming term (${message.term}) is higher than my term (${term}), stepping down`;\n    debug(logMessage);\n    span.addEvent('stepping-down', {\n      incomingTerm: message.term,\n      myTerm: term,\n    });\n    stepDown(span, message.term);\n  }\n\n  if (state == RaftServerState.CANDIDATE && term == message.term) {\n    const peer = peers[message.from];\n    peer.voteGranted = message.granted;\n\n    sendStateUpdate();\n    sendMessage({\n      type: RaftServerWorkerMessageType.PROXY_EVENT,\n      payload: {\n        type: RaftServerEvents.RECIEVED_VOTE,\n      },\n    });\n\n    // Check if we're leader now\n    const quorum = Math.ceil((Object.keys(peers).length + 1) / 2);\n    let grantedVotes = 1;\n    Object.values(peers).forEach((peer) => {\n      if (peer.voteGranted) grantedVotes++;\n    });\n\n    if (grantedVotes >= quorum) {\n      span?.addEvent('become-leader', { grantedVotes, quorum });\n      debug('Became LEADER');\n      state = RaftServerState.LEADER;\n      Object.values(peers).forEach((peer) => {\n        peer.nextIndex = log.length + 1;\n        sendAppendEntriesMessage(span, peer.id);\n      });\n\n      clearElectionTimeout();\n\n      sendStateUpdate();\n      sendMessage({\n        type: RaftServerWorkerMessageType.PROXY_EVENT,\n        payload: {\n          type: RaftServerEvents.BECAME_LEADER,\n        },\n      });\n    }\n  }\n\n  span?.end();\n}\n\nfunction sendAppendEntriesMessage(\n  parentSpan: opentelemetry.Span,\n  peerId: string\n) {\n  const peer = peers[peerId];\n  if (!peer) return;\n\n  const span = tracer.startSpan('appendEntries', {\n    links: [{ context: parentSpan?.context() }],\n  });\n\n  const prevIndex = peer.nextIndex - 1;\n  let lastIndex = Math.min(prevIndex + cfg.BATCH_SIZE, log.length);\n  if (peer.matchIndex + 1 < peer.nextIndex) lastIndex = prevIndex;\n\n  const message: AppendEntriesMessage = {\n    id: generateMessageId(),\n    from: id,\n    to: peerId,\n    term: term,\n    type: 'AppendEntries',\n    prevIndex: prevIndex,\n    prevTerm: logTerm(log, prevIndex),\n    entries: log.slice(prevIndex, lastIndex),\n    commitIndex: Math.min(commitIndex, lastIndex),\n  };\n\n  span.setAttributes({\n    to: peerId,\n    term: term,\n    prevIndex: message.prevIndex,\n    prevTerm: message.prevTerm,\n    entries: message.entries.map((e) => e.value).join(','),\n    commitIndex: message.commitIndex,\n  });\n  const ctx = opentelemetry.setSpan(opentelemetry.context.active(), span);\n  opentelemetry.propagation.inject(ctx, message);\n  rpcSpans[message.id] = span;\n\n  sendMessageToPeer(message, cfg.RPC_TIMEOUT);\n}\n\n// Can be in 3 states\nasync function handleAppendEntriesMessage(message: AppendEntriesMessage) {\n  let success = false;\n  let matchIndex = 0;\n\n  const ctx = opentelemetry.propagation.extract(\n    opentelemetry.context.active(),\n    message\n  );\n  const span = tracer.startSpan('handleAppendEntries', {}, ctx);\n  span.setAttributes({\n    ...dumpStateAsSpanAttributes(),\n    'request.term': message.term,\n    'request.prevIndex': message.prevIndex,\n    'request.entries': message.entries,\n    'request.commitIndex': message.commitIndex,\n  } as any);\n\n  debug(`Recieved ${message.type} message from ${message.from}`, message);\n\n  if (term < message.term) {\n    const logMessage = `Incoming term (${message.term}) is higher than my term (${term}), stepping down`;\n    debug(logMessage);\n    span.addEvent('stepping-down', {\n      incomingTerm: message.term,\n      myTerm: term,\n    });\n    stepDown(span, message.term);\n  }\n\n  if (term == message.term) {\n    state = RaftServerState.FOLLOWER;\n    reloadElectionTimeout(span);\n\n    if (\n      message.prevIndex == 0 ||\n      (message.prevIndex <= log.length &&\n        logTerm(log, message.prevIndex) == message.prevTerm)\n    ) {\n      success = true;\n      let index = message.prevIndex;\n\n      message.entries.forEach((entry, i) => {\n        index++;\n        if (logTerm(log, index) != entry.term) {\n          while (log.length > index - 1) {\n            log.pop();\n          }\n\n          log.push(entry);\n        }\n      });\n\n      // this.log is changed, however we're not calling `advanceCommitIndex`,\n      // we're updating `this.commitIndex` anyway.\n\n      matchIndex = index;\n      commitIndex = Math.max(commitIndex, message.commitIndex);\n    }\n\n    sendStateUpdate();\n    sendMessage({\n      type: RaftServerWorkerMessageType.PROXY_EVENT,\n      payload: {\n        type: RaftServerEvents.RECIEVED_APPEND_ENTRIES,\n      },\n    });\n  }\n\n  const response: AppendEntriesResponseMessage = {\n    id: message.id,\n    from: id,\n    to: message.from,\n    term: term,\n    type: 'AppendEntriesResponse',\n    success,\n    matchIndex,\n  };\n  sendMessageToPeer(response);\n\n  span.setAttributes({ success, matchIndex });\n\n  await sleep(minSpanDuration); // make the span visually pleasing\n  span.end();\n}\n\n// Can be in 3 states\nfunction handleAppendEntriesResponse(message: AppendEntriesResponseMessage) {\n  const span = rpcSpans[message.id];\n  delete rpcSpans[message.id];\n  span?.addEvent('response-recieved', {\n    // ...dumpState(),\n    'response.term': message.term,\n    'response.success': message.success,\n    'response.matchIndex': message.matchIndex,\n  });\n  if (!message.success) {\n    span?.setAttributes({ error: 'not success' });\n  }\n\n  debug(`Recieved ${message.type} message from ${message.from}`, message);\n\n  if (term < message.term) {\n    const logMessage = `Incoming term (${message.term}) is higher than my term (${term}), stepping down`;\n    debug(logMessage);\n    span.addEvent('stepping-down', {\n      incomingTerm: message.term,\n      myTerm: term,\n    });\n    stepDown(span, message.term);\n  }\n\n  const peerId = message.from;\n\n  if (state == RaftServerState.LEADER && term == message.term) {\n    const peer = peers[peerId];\n\n    if (message.success) {\n      peer.matchIndex = Math.max(peer.matchIndex, message.matchIndex);\n      peer.nextIndex = message.matchIndex + 1;\n\n      // `peers.matchIndex` is probably changed\n      advanceCommitIndex();\n    } else {\n      peer.nextIndex = Math.max(1, peer.nextIndex - 1);\n    }\n\n    // If peer.nextIndex <= log.length, call `sendAppendEntriesMessage` now,\n    // If not, we're gonna wait for heartbeat timeout\n    if (peer.nextIndex <= log.length) {\n      span?.addEvent('logs-missing-resending');\n      sendAppendEntriesMessage(span, peerId);\n    } else {\n      span?.addEvent('logs-up-to-date');\n      clearTimeout(peer.heartbeatTimeoutId);\n      peer.heartbeatTimeoutId = setTimeout(() => {\n        if (state == RaftServerState.STOPPED) return;\n        if (state == RaftServerState.LEADER) {\n          sendAppendEntriesMessage(span, peerId);\n        }\n      }, cfg.HEARTBEAT_INTERVAL) as any;\n    }\n\n    sendStateUpdate();\n  }\n\n  span?.end();\n}\n\n// Can be in 4 states\nfunction handleMessageTimeout(message: RaftMessage) {\n  const span = rpcSpans[message.id];\n  delete rpcSpans[message.id];\n  span?.setAttributes({ error: 'timeout' });\n\n  debug(`Message timeout`, message);\n\n  if (state == RaftServerState.STOPPED) {\n    span?.end();\n    return;\n  }\n\n  // If we couldn't successfully reply a message, noop.\n  // The requesters will request again.\n  if (\n    message.type == 'AppendEntriesResponse' ||\n    message.type == 'RequestVoteResponse'\n  ) {\n    span?.addEvent('timeout', { messageType: message.type });\n    span?.end();\n    return;\n  }\n\n  // Maybe new term has began (election timeout). If so, we don't want to retry again\n  if (message.term != term) {\n    span?.addEvent('timeout', { termChanged: true, noop: true });\n    span?.end();\n    return;\n  }\n\n  // If we couldn't send RequestVote message, and we're\n  // still candidate, try again\n  if (message.type == 'RequestVote' && state == RaftServerState.CANDIDATE) {\n    span?.addEvent('timeout', { resending: true });\n    span?.end();\n    // debug(`Timeout for sending ${message.type} message to ${message.to}, retrying...`, message);\n    sendRequestVoteMessage(span, message.to);\n    return;\n  }\n\n  // If we couldn't send AppendEntries message, and we're\n  // still leader, try again\n  if (message.type == 'AppendEntries' && state == RaftServerState.LEADER) {\n    span?.addEvent('timeout', { resending: true });\n    span?.end();\n    // debug(`Timeout for sending ${message.type} message to ${message.to}, retrying...`, message);\n    sendAppendEntriesMessage(span, message.to);\n    return;\n  }\n}\n\n// When to call these function? When the following change:\n// - peers.matchIndex\n// - this.log.length\n// - this.term\n//\n// However if we're sure that we're not leader, no need to call\nfunction advanceCommitIndex() {\n  const matchIndexes = [];\n  Object.values(peers).forEach((peer) => matchIndexes.push(peer.matchIndex));\n  matchIndexes.push(log.length);\n  matchIndexes.sort((a, b) => a - b);\n  const n = matchIndexes[Math.floor((Object.keys(peers).length + 1) / 2)];\n\n  if (state == RaftServerState.LEADER && logTerm(log, n) == term) {\n    commitIndex = Math.max(commitIndex, n);\n    sendStateUpdate();\n  }\n}\n\nfunction dumpStateAsSpanAttributes() {\n  return {\n    'self.state': state,\n    'self.term': term,\n    'self.votedFor': votedFor,\n    'self.logs': log.map((l, i) => l.value).join(','),\n    'self.logsLength': log.length,\n    'self.commitIndex': commitIndex,\n  };\n}\n\n////////////////////////////////////////////\n////////////// PUBLIC METHODS //////////////\n////////////////////////////////////////////\n\nasync function stop() {\n  if (state == RaftServerState.STOPPED) {\n    return;\n  }\n\n  const span = tracer.startSpan('stop', {});\n\n  state = RaftServerState.STOPPED;\n  clearTimeout(electionTimeoutId);\n  Object.values(peers).forEach((peer) => {\n    clearTimeout(peer.heartbeatTimeoutId);\n  });\n\n  sendStateUpdate();\n  sendMessage({\n    type: RaftServerWorkerMessageType.PROXY_EVENT,\n    payload: {\n      type: RaftServerEvents.STOPPED,\n    },\n  });\n\n  await sleep(minSpanDuration); // make the span visually pleasing\n  span.end();\n}\n\nasync function start() {\n  if (state != RaftServerState.STOPPED) {\n    return;\n  }\n\n  const span = tracer.startSpan('start', {});\n\n  state = RaftServerState.FOLLOWER;\n  reloadElectionTimeout(span);\n\n  sendStateUpdate();\n  sendMessage({\n    type: RaftServerWorkerMessageType.PROXY_EVENT,\n    payload: {\n      type: RaftServerEvents.STARTED,\n    },\n  });\n\n  await sleep(minSpanDuration); // make the span visually pleasing\n  span.end();\n}\n\nasync function request(value: string) {\n  const span = tracer.startSpan('request', {});\n  span.setAttributes({\n    ...dumpStateAsSpanAttributes(),\n    value,\n  });\n\n  log.push({\n    term: term,\n    value,\n  });\n\n  sendStateUpdate();\n  sendMessage({\n    type: RaftServerWorkerMessageType.PROXY_EVENT,\n    payload: {\n      type: RaftServerEvents.LOG_REQUESTED,\n    },\n  });\n\n  await sleep(minSpanDuration); // make the span visually pleasing\n  span.end();\n}\n\nasync function forceTriggerElection() {\n  const span = tracer.startSpan('forceTriggerElection', {});\n  span.setAttributes({ ...dumpStateAsSpanAttributes() });\n\n  handleElectionTimeout(span);\n\n  await sleep(minSpanDuration); // make the span visually pleasing\n  span.end();\n}\n\n///////////////////////////////////////////////////\n///////////////// EVENT LISTENING /////////////////\n///////////////////////////////////////////////////\n\nself.addEventListener('message', (event) => {\n  const message = JSON.parse(event.data) as RaftServerWorkerMessage;\n\n  if (message.type == RaftServerWorkerMessageType.INIT) {\n    const { id: id_, peerIds } = message.payload;\n\n    id = id_;\n    tracer = opentelemetry.trace.getTracer(`raft-server-${id}`);\n\n    peerIds.forEach((peerId: string) => {\n      peers[peerId] = {\n        id: peerId,\n        voteGranted: false,\n        matchIndex: 0,\n        nextIndex: 1,\n        heartbeatTimeoutId: null,\n      };\n    });\n\n    setupTracing();\n\n    sendMessage({ type: RaftServerWorkerMessageType.READY });\n  }\n\n  if (message.type == RaftServerWorkerMessageType.MESSAGE_FROM_PEER) {\n    // Can be in 4 states\n    clearTimeout(rpcTimeoutIds[message.payload.id]);\n    delete rpcTimeoutIds[message.payload.id];\n\n    if (state == RaftServerState.STOPPED) {\n      return;\n    }\n\n    // Can be in 4 states\n    switch (message.payload.type) {\n      case 'AppendEntries':\n        return handleAppendEntriesMessage(message.payload);\n      case 'AppendEntriesResponse':\n        return handleAppendEntriesResponse(message.payload);\n      case 'RequestVote':\n        return handleRequestVoteMessage(message.payload);\n      case 'RequestVoteResponse':\n        return handleRequestVoteResponse(message.payload);\n    }\n  }\n\n  if (message.type == RaftServerWorkerMessageType.START) {\n    start();\n  }\n\n  if (message.type == RaftServerWorkerMessageType.STOP) {\n    stop();\n  }\n\n  if (message.type == RaftServerWorkerMessageType.REQUEST) {\n    request(message.payload.value);\n  }\n\n  if (message.type == RaftServerWorkerMessageType.FORCE_TRIGGER_ELECTION) {\n    forceTriggerElection();\n  }\n});\n\nfunction sendStateUpdate() {\n  sendMessage({\n    type: RaftServerWorkerMessageType.STATE_UPDATE,\n    payload: {\n      state,\n      term,\n      votedFor,\n      log,\n      peers,\n    },\n  });\n}\n\nfunction sendMessage(message: RaftServerWorkerMessage) {\n  (self.postMessage as any)(JSON.stringify(message));\n}\n\nfunction generateMessageId() {\n  return Math.random().toString(36).substring(2, 7);\n}\n\nfunction logTerm(log: RaftLogItem[], index: number = log.length) {\n  if (index < 1 || index > log.length) {\n    return 0;\n  } else {\n    return log[index - 1].term;\n  }\n}\n\nfunction debug(message: string, ...args: any) {\n  // console.log(`[${id}] ${message}`, args);\n}\n\nfunction setupTracing() {\n  const provider = new BasicTracerProvider();\n\n  ////////////////////////////////////\n  ///////// CONSOLE EXPORTER /////////\n  ////////////////////////////////////\n  // provider.addSpanProcessor(new SimpleSpanProcessor(new ConsoleSpanExporter()));\n\n  /////////////////////////////////////////////\n  ////////// OTEL-COLLECTOR EXPORTER //////////\n  /////////////////////////////////////////////\n  // const exporter = new CollectorTraceExporter({\n  //   // url: '<opentelemetry-collector-url>', // url is optional and can be omitted - default is http://localhost:55681/v1/trace\n  //   serviceName: `raft-server`,\n  //   hostname: id,\n  //   attributes: {\n  //     // for jeager process: https://github.com/open-telemetry/opentelemetry-specification/blob/main/specification/resource/semantic_conventions/process.md#process\n  //     'process.executable.name': id,\n  //   },\n  //   // headers: {}, // an optional object containing custom headers to be sent with each request\n  //   concurrencyLimit: 10, // an optional limit on pending requests\n  // });\n  // provider.addSpanProcessor(\n  //   new BatchSpanProcessor(exporter, {\n  //     // The maximum queue size. After the size is reached spans are dropped.\n  //     maxQueueSize: 100,\n  //     // The maximum batch size of every export. It must be smaller or equal to maxQueueSize.\n  //     maxExportBatchSize: 10,\n  //     // The interval between two consecutive exports\n  //     scheduledDelayMillis: 500,\n  //     // How long the export can run before it is cancelled\n  //     exportTimeoutMillis: 30000,\n  //   })\n  // );\n\n  /////////////////////////////////////////\n  ////////// STALK SPAN EXPORTER //////////\n  /////////////////////////////////////////\n  provider.addSpanProcessor(\n    new SimpleSpanProcessor(new WorkerStalkSpanExporter(id))\n  );\n\n  provider.register();\n}\n\nsendMessage({ type: RaftServerWorkerMessageType.LOADED });\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\tid: moduleId,\n\t\tloaded: false,\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n\t// Flag the module as loaded\n\tmodule.loaded = true;\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n// expose the modules object (__webpack_modules__)\n__webpack_require__.m = __webpack_modules__;\n\n// the startup function\n__webpack_require__.x = () => {\n\t// Load entry module and return exports\n\t// This entry module depends on other loaded chunks and execution need to be delayed\n\tvar __webpack_exports__ = __webpack_require__.O(undefined, [745], () => (__webpack_require__(1912)))\n\t__webpack_exports__ = __webpack_require__.O(__webpack_exports__);\n\treturn __webpack_exports__;\n};\n\n","__webpack_require__.f = {};\n// This file contains only the entry chunk.\n// The chunk loading function for additional chunks\n__webpack_require__.e = (chunkId) => {\n\treturn Promise.all(Object.keys(__webpack_require__.f).reduce((promises, key) => {\n\t\t__webpack_require__.f[key](chunkId, promises);\n\t\treturn promises;\n\t}, []));\n};","// This function allow to reference async chunks and sibling chunks for the entrypoint\n__webpack_require__.u = (chunkId) => {\n\t// return url for filenames based on template\n\treturn \"\" + chunkId + \".index.js\";\n};","__webpack_require__.g = (function() {\n\tif (typeof globalThis === 'object') return globalThis;\n\ttry {\n\t\treturn this || new Function('return this')();\n\t} catch (e) {\n\t\tif (typeof window === 'object') return window;\n\t}\n})();","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","__webpack_require__.nmd = (module) => {\n\tmodule.paths = [];\n\tif (!module.children) module.children = [];\n\treturn module;\n};","var scriptUrl;\nif (__webpack_require__.g.importScripts) scriptUrl = __webpack_require__.g.location + \"\";\nvar document = __webpack_require__.g.document;\nif (!scriptUrl && document) {\n\tif (document.currentScript)\n\t\tscriptUrl = document.currentScript.src\n\tif (!scriptUrl) {\n\t\tvar scripts = document.getElementsByTagName(\"script\");\n\t\tif(scripts.length) scriptUrl = scripts[scripts.length - 1].src\n\t}\n}\n// When supporting browsers where an automatic publicPath is not supported you must specify an output.publicPath manually via configuration\n// or pass an empty string (\"\") and set the __webpack_public_path__ variable from your code to use your own logic.\nif (!scriptUrl) throw new Error(\"Automatic publicPath is not supported in this browser\");\nscriptUrl = scriptUrl.replace(/#.*$/, \"\").replace(/\\?.*$/, \"\").replace(/\\/[^\\/]+$/, \"/\");\n__webpack_require__.p = scriptUrl;","// no baseURI\n\n// object to store loaded chunks\n// \"1\" means \"already loaded\"\nvar installedChunks = {\n\t912: 1\n};\n\n// importScripts chunk loading\nvar installChunk = (data) => {\n\tvar [chunkIds, moreModules, runtime] = data;\n\tfor(var moduleId in moreModules) {\n\t\tif(__webpack_require__.o(moreModules, moduleId)) {\n\t\t\t__webpack_require__.m[moduleId] = moreModules[moduleId];\n\t\t}\n\t}\n\tif(runtime) runtime(__webpack_require__);\n\twhile(chunkIds.length)\n\t\tinstalledChunks[chunkIds.pop()] = 1;\n\tparentChunkLoadingFunction(data);\n};\n__webpack_require__.f.i = (chunkId, promises) => {\n\t// \"1\" is the signal for \"already loaded\"\n\tif(!installedChunks[chunkId]) {\n\t\tif(true) { // all chunks have JS\n\t\t\timportScripts(__webpack_require__.p + __webpack_require__.u(chunkId));\n\t\t}\n\t}\n};\n\nvar chunkLoadingGlobal = self[\"webpackChunkstalk_demo_raft_consensus\"] = self[\"webpackChunkstalk_demo_raft_consensus\"] || [];\nvar parentChunkLoadingFunction = chunkLoadingGlobal.push.bind(chunkLoadingGlobal);\nchunkLoadingGlobal.push = installChunk;\n\n// no HMR\n\n// no HMR manifest","// run startup\nvar __webpack_exports__ = __webpack_require__.x();\n"],"sourceRoot":""}